<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>
  <body>

<script>
// Componente de Holograma Profissional com Shader e Glitch
AFRAME.registerComponent('hologram-glitch', {
  schema: {
    color: { type: 'color', default: '#00ffff' }
  },

  init: function() {
    // Uniforms: variáveis passadas do JS para o Shader
    this.uniforms = {
      time: { value: 0 },
      color: { value: new THREE.Color(this.data.color) },
      glitchIntensity: { value: 0.0 } // Nova variável para controlar a força da falha
    };

    // --- Variáveis de controle do Glitch no JS ---
    this.glitchChance = 0.01;   // 1% de chance por frame de iniciar um glitch
    this.isGlitching = false;   // Estado atual
    this.glitchDuration = 0;    // Quanto tempo dura a falha atual
    this.glitchTimer = 0;       // Cronômetro da falha atual

    // --- Funções auxiliares para Shaders (Ruído) ---
    const noiseChunk = `
      // Função de ruído pseudo-aleatório padrão
      float rand(vec2 co){
          return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }
    `;

    // --- Vertex Shader (Distorção Geométrica) ---
    const vertexShader = `
      ${noiseChunk}
      uniform float time;
      uniform float glitchIntensity;

      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vViewPosition;
      
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vec3 pos = position;

        // Efeito Glitch Geométrico
        if (glitchIntensity > 0.0) {
            // Cria "faixas" horizontais aleatórias baseadas na altura (Y) e no tempo
            float stripNoise = rand(vec2(floor(pos.y * 20.0), time * 15.0));
            
            // Se cair na faixa de ruído, desloca o vértice horizontalmente (X)
            if (stripNoise > 0.5) {
                 float shift = (rand(vec2(time * 10.0, pos.y)) * 2.0 - 1.0); // -1 a 1
                 pos.x += shift * glitchIntensity * 0.15; // Deslocamento
            }
        }

        vPosition = pos;
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        vViewPosition = -mvPosition.xyz;
        gl_Position = projectionMatrix * mvPosition;
      }
    `;

    // --- Fragment Shader (Cor e Textura) ---
    const fragmentShader = `
      ${noiseChunk}
      uniform float time;
      uniform vec3 color;
      uniform float glitchIntensity;

      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vViewPosition;

      void main() {
        // 1. Fresnel (Borda)
        vec3 normal = normalize(vNormal);
        vec3 viewDir = normalize(vViewPosition);
        float rim = pow(1.0 - abs(dot(normal, viewDir)), 2.5);

        // 2. Scanlines
        float scanline = smoothstep(0.4, 0.6, sin(vPosition.y * 50.0 - time * 5.0));
        
        // 3. Pulsação
        float pulse = 0.8 + 0.2 * sin(time * 3.0);

        // 4. Efeito Glitch na Cor/Alfa
        float glitchNoise = 0.0;
        vec3 glitchColorOffset = vec3(0.0);
        if (glitchIntensity > 0.0) {
             // Ruído estático rápido
             glitchNoise = rand(vec2(gl_FragCoord.xy * time)) * glitchIntensity;
             // Pisca para branco durante o glitch intenso
             glitchColorOffset = vec3(1.0) * glitchIntensity * rand(vec2(time));
        }

        // Combinação
        float alpha = rim + (scanline * 0.2) + glitchNoise;
        vec3 finalColor = (color * pulse) + (color * rim * 2.0) + (vec3(1.0) * scanline * 0.3) + glitchColorOffset;

        // Aumenta a opacidade geral durante um glitch forte para "estourar" a luz
        gl_FragColor = vec4(finalColor, alpha * clamp(pulse + glitchIntensity, 0.5, 1.2));
      }
    `;

    const material = new THREE.ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      transparent: true,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    this.el.addEventListener('model-loaded', () => {
      const mesh = this.el.getObject3D('mesh');
      if (!mesh) return;
      mesh.traverse((node) => {
        if (node.isMesh) node.material = material;
      });
    });
  },

  // O loop de animação (roda todo frame)
  tick: function(t, dt) {
    if (!dt) return;
    const deltaSeconds = dt / 1000;
    this.uniforms.time.value += deltaSeconds;

    // --- Lógica do Glitch Aleatório ---
    if (!this.isGlitching) {
        // Tenta iniciar um glitch se não estiver ocorrendo um
        if (Math.random() < this.glitchChance) {
            this.isGlitching = true;
            this.glitchDuration = 0.1 + Math.random() * 0.4; // Dura entre 0.1s e 0.5s
            this.glitchTimer = 0;
        } else {
             this.uniforms.glitchIntensity.value = 0.0; // Sem glitch
        }
    }

    if (this.isGlitching) {
        this.glitchTimer += deltaSeconds;
        if (this.glitchTimer >= this.glitchDuration) {
            // Fim do glitch
            this.isGlitching = false;
            this.uniforms.glitchIntensity.value = 0.0;
        } else {
            // Durante o glitch, a intensidade varia loucamente para piscar
            this.uniforms.glitchIntensity.value = Math.random() * 0.9 + 0.1;
        }
    }
  }
});
</script>

    <a-scene
      mindar-image="imageTargetSrc: https://igorsousafront.github.io/firma-2025/assets/targets-v2.mind; 
                    filterMinCF: 0.001; 
                    filterBeta: 2.5;"
      embedded
      vr-mode-ui="enabled: false"
      renderer="colorManagement: true; physicallyCorrectLights: true; antialias: true; alpha: true;"
    >

      <a-assets>
        <a-asset-item
          id="modelo"
          src="https://igorsousafront.github.io/firma-2025/assets/firma-logo.glb">
        </a-asset-item>
      </a-assets>

      <a-entity mindar-image-target="targetIndex: 0; targetWidth: 0.12">
        <a-gltf-model
          src="#modelo"
          hologram-glitch="color: #00ffff"
          scale="0.5 0.5 0.5"
          position="0 0 0"
          animation="property: rotation; to: 0 360 0; loop: true; dur: 15000; easing: linear">
        </a-gltf-model>
      </a-entity>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
    </a-scene>
  </body>
</html>