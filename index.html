<html>
  <head>
    <script>
      if (window.location.protocol === 'http:') {
        window.location.href = window.location.href.replace('http:', 'https:');
        console.log('redirecionou')
      }
    </script>
    <script>
  // Tenta forçar a câmera traseira padrão
  const constraints = {
    video: {
      facingMode: { exact: "environment" },
      // Tentar forçar uma proporção que a ultrawide geralmente não usa como primária
      aspectRatio: { ideal: 1.7777777778 } 
    }
  };
  
  // O MindAR internamente chama o getUserMedia. 
  // Forçar isso pode ajudar em alguns aparelhos.
</script>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>
  <body>

<script>

AFRAME.registerComponent('hologram-glitch', {
  schema: {
    color: { type: 'color', default: '#ffffff' },
    loopSpeed: { type: 'number', default: 1.5 }, // Velocidade do ciclo
    minScale: { type: 'number', default: 0.5 },  // Escala mínima no desaparecimento
    maxScale: { type: 'number', default: 1.2 }   // Escala máxima no zoom
  },

  init: function() {
    this.uniforms = {
      time: { value: 0 },
      color: { value: new THREE.Color(this.data.color) },
      glitchIntensity: { value: 0.0 },
      spawnFade: { value: 1.0 } 
    };

    this.glitchChance = 0.008;
    this.isGlitching = false;
    this.glitchDuration = 0;
    this.glitchTimer = 0;

    const noiseChunk = `
      float rand(vec2 co){
          return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }
    `;

    const vertexShader = `
      ${noiseChunk}
      uniform float time;
      uniform float glitchIntensity;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vViewPosition;
      
      void main() {
        vNormal = normalize(normalMatrix * normal);
        vec3 pos = position;
        if (glitchIntensity > 0.0) {
            float stripNoise = rand(vec2(floor(pos.y * 20.0), time * 15.0));
            if (stripNoise > 0.5) {
                 float shift = (rand(vec2(time * 10.0, pos.y)) * 2.0 - 1.0);
                 pos.x += shift * glitchIntensity * 0.15;
            }
        }
        vPosition = pos;
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        vViewPosition = -mvPosition.xyz;
        gl_Position = projectionMatrix * mvPosition;
      }
    `;

    const fragmentShader = `
      ${noiseChunk}
      uniform float time;
      uniform vec3 color;
      uniform float glitchIntensity;
      uniform float spawnFade;
      varying vec3 vNormal;
      varying vec3 vPosition;
      varying vec3 vViewPosition;

      void main() {
        vec3 normal = normalize(vNormal);
        vec3 viewDir = normalize(vViewPosition);
        float rim = pow(1.0 - abs(dot(normal, viewDir)), 2.5);
        float scanline = smoothstep(0.4, 0.6, sin(vPosition.y * 50.0 - time * 5.0));
        float pulse = 0.8 + 0.2 * sin(time * 3.0);
        
        float glitchNoise = 0.0;
        if (glitchIntensity > 0.0) {
             glitchNoise = rand(vec2(gl_FragCoord.xy * time)) * glitchIntensity;
        }

        // spawnFade agora oscila no tempo
        float alpha = (rim + (scanline * 0.2) + glitchNoise) * spawnFade;
        vec3 finalColor = (color * pulse) + (color * rim * 2.0) + (vec3(1.0) * scanline * 0.3);
        
        gl_FragColor = vec4(finalColor, alpha);
      }
    `;

    const material = new THREE.ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      transparent: true,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    this.el.addEventListener('model-loaded', () => {
      const mesh = this.el.getObject3D('mesh');
      if (!mesh) return;
      mesh.traverse((node) => {
        if (node.isMesh) node.material = material;
      });
    });
  },

  tick: function(t, dt) {
    if (!dt) return;
    const deltaSeconds = dt / 1000;
    this.uniforms.time.value += deltaSeconds;

    // --- LÓGICA DE LOOP (ZOOM + FADE) ---
    // Criamos uma onda que vai de 0 a 1 usando Math.cos
    // Usamos o tempo acumulado para criar a oscilação
    let wave = (Math.cos(t / 1000 * this.data.loopSpeed) + 1) / 2; 
    
    // Inverter para que comece aparecendo ou ajuste conforme preferir
    // 0.0 = Invisível/Pequeno, 1.0 = Visível/Grande
    let intensity = wave; 

    // Ajuste da Escala (Zoom)
    let currentScale = this.data.minScale + (this.data.maxScale - this.data.minScale) * intensity;
    this.el.object3D.scale.set(currentScale, currentScale, currentScale);

    // Ajuste da Opacidade (Fade) via Uniform
    this.uniforms.spawnFade.value = intensity;

    // --- LÓGICA DE GLITCH ORIGINAL ---
    if (!this.isGlitching) {
        if (Math.random() < this.glitchChance) {
            this.isGlitching = true;
            this.glitchDuration = 0.1 + Math.random() * 0.4;
            this.glitchTimer = 0;
        }
    } else {
        this.glitchTimer += deltaSeconds;
        if (this.glitchTimer >= this.glitchDuration) {
            this.isGlitching = false;
            this.uniforms.glitchIntensity.value = 0.0;
        } else {
            this.uniforms.glitchIntensity.value = Math.random() * 0.9 + 0.1;
        }
    }
  }
});
</script>

    <a-scene
      mindar-image="imageTargetSrc: https://igorsousafront.github.io/firma-2025/assets/targets-v2.mind; 
                    filterMinCF: 0.0001; 
                    filterBeta: 0.001;
                    warmupTolerance: 1;
                    missTolerance: 5;"
      inspector-plugin-recast
      embedded
      renderer="colorManagement: true; physicallyCorrectLights: true; antialias: true; alpha: true;"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false"
    >

      <a-assets>
        <a-asset-item
          id="modelo"
          src="https://igorsousafront.github.io/firma-2025/assets/firma-logo-final.glb">
        </a-asset-item>
      </a-assets>

      <a-entity mindar-image-target="targetIndex: 0; targetWidth: 0.21">
        <a-gltf-model
          src="#modelo"
          hologram-glitch="color: #ffffff; loopSpeed: 0.3; minScale: 0.2; maxScale: 0.7"
          position="0 0 0" 
          rotation="0 0 0"
          scale="0.5 0.5 0.5"
        >
        </a-gltf-model>
      </a-entity>

      <a-camera position="0 0 0" look-controls="enabled: false" wasd-controls="enabled: false"></a-camera>
    </a-scene>
  </body>
</html>